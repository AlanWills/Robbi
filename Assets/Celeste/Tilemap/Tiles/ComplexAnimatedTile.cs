using System;
using UnityEngine;
using UnityEngine.Tilemaps;

namespace Celeste.Tilemaps
{
    [Serializable]
    [CreateAssetMenu(fileName = "New Complex Animated Tile", menuName = "Celeste/Tiles/Complex Animated Tile")]
    public class ComplexAnimatedTile : TileBase
    {
        /// <summary>
        /// The List of Sprites set for the Animated Tile.
        /// This will be played in sequence.
        /// </summary>
        public Sprite[] m_AnimatedSprites;
        /// <summary>
        /// The minimum possible speed at which the Animation of the Tile will be played.
        /// A speed value will be randomly chosen between the minimum and maximum speed.
        /// </summary>
        public float m_Speed = 1f;
        /// <summary>
        /// The Collider Shape generated by the Tile.
        /// </summary>
        public Tile.ColliderType m_TileColliderType;

        public int previewIndex = 0;

        public bool loop = true;
        public bool playImmediately = true;

        protected bool reverse = false;

        private int currentFrame = 0;
        private float currentFrameTime = 0;
        private bool isPlaying = true;

        private void Awake()
        {
            isPlaying = playImmediately;
        }
        
        /// <summary>
        /// Retrieves any tile rendering data from the scripted tile.
        /// </summary>
        /// <param name="position">Position of the Tile on the Tilemap.</param>
        /// <param name="tilemap">The Tilemap the tile is present on.</param>
        /// <param name="tileData">Data to render the tile.</param>
        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData)
        {
            tileData.transform = Matrix4x4.identity;
            tileData.color = Color.white;

            if (m_AnimatedSprites != null && m_AnimatedSprites.Length > 0)
            {
                tileData.sprite = m_AnimatedSprites[currentFrame];
                tileData.colliderType = m_TileColliderType;

                if (isPlaying)
                {
                    float timePerFrame = 1 / m_Speed;
                    currentFrameTime += Time.deltaTime;

                    while (currentFrameTime > timePerFrame && isPlaying)
                    {
                        currentFrameTime -= timePerFrame;

                        if (reverse)
                        {
                            --currentFrame;
                            currentFrame = loop ? (int)Mathf.Repeat(currentFrame, m_AnimatedSprites.Length) : Math.Max(currentFrame, 0);
                            isPlaying = loop || currentFrame > 0;
                        }
                        else
                        {
                            ++currentFrame;
                            currentFrame = loop ? currentFrame % m_AnimatedSprites.Length : Math.Min(currentFrame, m_AnimatedSprites.Length - 1);
                            isPlaying = loop || currentFrame < m_AnimatedSprites.Length - 1;
                        }
                    }
                }
                else if (Application.isEditor && !Application.isPlaying)
                {
                    currentFrame = previewIndex;
                    tileData.sprite = m_AnimatedSprites[previewIndex];
                }
            }
        }

        public void Play()
        {
            isPlaying = true;
        }

        public void Stop()
        {
            isPlaying = false;
        }

        public void SetAtStart()
        {
            currentFrame = 0;
        }

        public void SetAtEnd()
        {
            currentFrame = m_AnimatedSprites.Length - 1;
        }
    }
}